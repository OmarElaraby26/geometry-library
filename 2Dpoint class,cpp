#define EPS 1e-9
#define Vector Point
#define T long long
class Point {
public:
	T x, y;
	Point() :
			x(0), y(0) {
	}

	Point(const T a, const T b) :
			x(a), y(b) {
	}

	Point(const Point &other) :
			Point(other.x, other.y) {
	}

	Point& operator=(const Point &other) {
		Point(other.x, other.y);
		return *this;
	}

	Point& operator -=(const Point &other) {
		Point(x - other.x, y - other.y);
		return *this;
	}

	Point& operator +=(const Point &other) {
		Point(x + other.x, y + other.y);
		return *this;
	}

	Point& operator *=(const Point &other) {
		Point(x * other.x, y * other.y);
		return *this;
	}

	Point operator+(const Point &other) const {
		return Point(x + other.x, y + other.y);
	}

	Point operator-(const Point &other) const {
		return Point(x - other.x, y - other.y);
	}

	Point operator *(const T factor) const {
		return Point(x * factor, y * factor);
	}

	Point operator-() const {
		return Point(-x, -y);
	}

	bool operator==(const Point &other) const {
		return (abs(x - other.x) < EPS && abs(y - other.y) < EPS);
	}

	bool operator!=(const Point &other) const {
		return !operator==(other);
	}

	bool operator<(const Point &other) const {
		if (abs(x - other.x) < EPS) { //equal
			if (abs(y - other.y) < EPS) return false;
			return y < other.y;
		}
		return x < other.x;
	}

	bool operator<=(const Point &other) const {
		return operator==(other) || operator<(other);
	}

	bool operator>(const Point &other) const {
		if (abs(x - other.x) < EPS) { //equal
			if (abs(y - other.y) < EPS) return false;
			return y > other.y;
		}
		return x > other.x;
	}

	bool operator>=(const Point &other) const {
		return operator==(other) || operator>(other);
	}

	Point translate(const Vector &v) const {
		return this->operator+(v);
	}

	// scaling vector p->c by ratio
	Point scale(const Point &c, const double ratio) {
		// make vector c->p then scale this vector by ratio
		// then get the new point and return it
		// return new Point p' not new Vector cp'
		return (*this - c) * ratio + c;
	}

// rotate point by theta degree around c point
	Point rotate(const Point &c, const double deg) {
		double rad = deg / 180.0 * acos(-1);

		Vector vec(*this - c);

		vec = Vector(vec.x * cos(rad) - vec.y * sin(rad),
				vec.y * cos(rad) + vec.x * sin(rad));

		return vec + c;
	}
};

Point make_point(const T a, const T b) {
	return Point(a, b);
}

ostream& operator<<(ostream &out, const Point p) {
	return out << p.x << ' ' << p.y;
}

template<class tp>
istream& operator>>(istream &in, Point &p) {
	return in >> p.x >> p.y;
}

Point scale(const Vector &v, const double ratio) {
	return v * ratio; // return new Vector v'
}

T cross(const Vector &a, const Vector &b) {
	// |a|*|b|*sin(x)
	return (a.x * b.y - a.y * b.x);
}

T dot(const Vector &a, const Vector &b) {
	// |a|*|b|*cos(x)
	return (a.x * b.x + a.y * b.y);
}

int main() {

	return 0;
}
